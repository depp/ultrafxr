use crate::utf8::UTF8Segments;
use std::ffi::OsStr;
use std::str;

const MASK_PLAIN: u8 = 1 << 0;
const MASK_SINGLE: u8 = 1 << 1;
const MASK_NOESCAPE: u8 = 1 << 2;

const HEX_DIGIT: [u8; 16] = *b"0123456789abcdef";
fn push_hex(s: &mut String, c: u32, n: u32) {
    for i in (0..n).rev() {
        s.push(HEX_DIGIT[((c >> (i * 4)) & 15) as usize] as char);
    }
}

// Generated by quote_table.rs
const TABLE: [u8; 128] = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //
    6, 6, 2, 6, 2, 7, 6, 4, 6, 6, 6, 7, 7, 7, 7, 7, //
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 7, 6, 6, //
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, //
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 2, 6, 6, 7, //
    2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, //
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 0, //
];

fn string_mask(s: &[u8]) -> u8 {
    let mut m = MASK_PLAIN | MASK_SINGLE | MASK_NOESCAPE;
    for &c in s.iter() {
        m &= if c < 128 { TABLE[c as usize] } else { 0 };
    }
    m
}

pub fn push_dquote(r: &mut String, s: &str) {
    for c in s.chars() {
        if c > '\x7f' {
            r.push('\\');
            if c > '\u{ffff}' {
                r.push('U');
                push_hex(r, c as u32, 8);
            } else {
                r.push('u');
                push_hex(r, c as u32, 4);
            }
        } else if TABLE[c as usize] & MASK_NOESCAPE != 0 {
            r.push(c);
        } else {
            r.push('\\');
            match c {
                '\x20'..='\x7e' => r.push(c),
                '\n' => r.push('n'),
                '\r' => r.push('r'),
                '\t' => r.push('t'),
                _ => {
                    r.push('x');
                    push_hex(r, c as u32, 2);
                }
            }
        }
    }
}

/// Quote a string as it would appear in a shell script.
pub fn quote_str(s: &str) -> String {
    if s.is_empty() {
        return "''".to_string();
    }
    let m = string_mask(s.as_bytes());
    if m & MASK_PLAIN != 0 {
        s.to_string()
    } else if m & MASK_SINGLE != 0 {
        let mut r = String::with_capacity(s.len() + 2);
        r.push('\'');
        r.push_str(s);
        r.push('\'');
        r
    } else {
        let mut r = String::new();
        r.push('"');
        push_dquote(&mut r, s);
        r.push('"');
        r
    }
}

/// Quote a string as it would appear in a shell script.
pub fn quote<T>(s: &T) -> String
where
    T: AsRef<str> + ?Sized,
{
    quote_str(s.as_ref())
}

/// Quote an OsStr u8 as it would appear in a shell script.
fn quote_u8(s: &[u8]) -> String {
    if s.is_empty() {
        return "''".to_string();
    }
    let m = string_mask(s);
    if m & MASK_PLAIN != 0 {
        str::from_utf8(s).unwrap().to_string()
    } else if m & MASK_SINGLE != 0 {
        let mut r = String::with_capacity(s.len() + 2);
        r.push('\'');
        r.push_str(str::from_utf8(s).unwrap());
        r.push('\'');
        r
    } else {
        let mut r = String::new();
        r.push('"');
        for seg in UTF8Segments(s) {
            match seg {
                Ok(s) => push_dquote(&mut r, s),
                Err(bs) => {
                    for &b in bs.iter() {
                        r.push_str("\\x");
                        push_hex(&mut r, b as u32, 2);
                    }
                }
            }
        }
        r.push('"');
        r
    }
}

/// Quote an OsStr as it would appear in a shell script.
fn quote_osstr(s: &OsStr) -> String {
    use std::os::unix::ffi::OsStrExt;
    quote_u8(s.as_bytes())
}

/// Quote an OsStr as it would appear in a shell script.
pub fn quote_os<T>(s: &T) -> String
where
    T: AsRef<OsStr> + ?Sized,
{
    quote_osstr(s.as_ref())
}

#[cfg(test)]
mod test {
    use super::{quote, quote_os};

    const CASES: &'static [(&'static str, &'static str)] = &[
        ("a", "a"),
        ("azAZ09_-%+,-./:=@_", "azAZ09_-%+,-./:=@_"),
        ("", "''"),
        // Special characters
        ("|", "'|'"),
        ("&", "'&'"),
        (";", "';'"),
        ("<", "'<'"),
        (">", "'>'"),
        ("$", "'$'"),
        ("`", "'`'"),
        ("\\", "'\\'"),
        ("\"", "'\"'"),
        ("'", "\"'\""),
        (" ", "' '"),
        ("`'\\$\"", "\"\\`'\\\\\\$\\\"\""),
        ("\x7f", "\"\\x7f\""),
        ("\r", "\"\\r\""),
        ("\n", "\"\\n\""),
        ("\t", "\"\\t\""),
        ("\x00", "\"\\x00\""),
        ("\u{0080}", "\"\\u0080\""),
        ("\u{ffff}", "\"\\uffff\""),
        ("\u{10000}", "\"\\U00010000\""),
    ];

    #[test]
    fn test_quote() {
        let mut success = true;
        for &(input, expect) in CASES.iter() {
            let output = quote(input);
            if output != expect {
                success = false;
                eprintln!("quote({:?}) = {:?}, expect {:?}", input, output, expect);
            }
        }
        if !success {
            eprintln!();
            panic!("failed");
        }
    }

    #[test]
    fn test_quote_os() {
        use std::ffi::OsStr;
        use std::os::unix::ffi::OsStrExt;
        const EXTRA_CASES: &'static [(&'static [u8], &'static str)] =
            &[(b"\xff", "\"\\xff\""), (b"\x80\x80", "\"\\x80\\x80\"")];
        let mut success = true;
        for &(input, expect) in CASES.iter() {
            let output = quote_os(input);
            if output != expect {
                success = false;
                eprintln!("quote({:?}) = {:?}, expect {:?}", input, output, expect);
            }
        }
        for &(input, expect) in EXTRA_CASES.iter() {
            let output = quote_os(OsStr::from_bytes(input));
            if output != expect {
                success = false;
                eprintln!("quote({:?}) = {:?}, expect {:?}", input, output, expect);
            }
        }
        if !success {
            eprintln!();
            panic!("failed");
        }
    }
}
