// util.c - Utility functions.
#include "c/util/util.h"

#include <errno.h>
#include <stdlib.h>

void read_file(struct data *restrict data, const char *name) {
    FILE *fp = fopen(name, "rb");
    if (fp == NULL) {
        goto error;
    }
    data->size = 0;
    while (1) {
        if (data->size >= data->alloc) {
            size_t alloc = data->alloc == 0 ? 4 * 1024 : data->alloc * 2;
            if (alloc == 0) {
                die_nomem();
            }
            data->ptr = xrealloc(data->ptr, alloc);
            data->alloc = alloc;
        }
        size_t req = data->alloc - data->size;
        size_t r = fread((char *)data->ptr + data->size, 1, req, fp);
        data->size += r;
        if (r < req) {
            if (feof(fp)) {
                break;
            }
            if (ferror(fp)) {
                goto error;
            }
        }
    }
    fclose(fp);
    return;
error:;
    int ecode = errno;
    dief(ecode, "could not read %s", quote_str(name));
}

void strings_push(struct strings *restrict strings, char *string) {
    if (strings->count == strings->alloc) {
        size_t alloc = strings->alloc == 0 ? 4 : strings->alloc * 2;
        if (alloc == 0) {
            die_nomem();
        }
        strings->strings =
            xrealloc(strings->strings, alloc * sizeof(*strings->strings));
        strings->alloc = alloc;
    }
    strings->strings[strings->count] = string;
    strings->count++;
}

void split_lines(struct strings *restrict lines, struct data *restrict data) {
    char *ptr = data->ptr, *end = ptr + data->size;
    if (ptr != end && *(end - 1) != '\n' && *(end - 1) != '\r') {
        if (data->size == data->alloc) {
            data->ptr = realloc(data->ptr, data->alloc + 1);
            data->alloc += 1;
            ptr = data->ptr;
            end = ptr + data->size;
        }
        *end++ = '\n';
        data->size++;
    }
    lines->count = 0;
    while (ptr != end) {
        strings_push(lines, ptr);
        while (*ptr != '\n' && *ptr != '\r') {
            ptr++;
        }
        char *eol = ptr;
        if (*ptr == '\r' && ptr + 1 != end && *(ptr + 1) == '\n') {
            ptr += 2;
        } else {
            ptr += 1;
        }
        *eol = '\0';
    }
}

void split_csv(struct strings *restrict fields, char *row) {
    fields->count = 0;
    char *ptr = row;
    while (1) {
        strings_push(fields, ptr);
        while (*ptr != ',' && *ptr != '\0') {
            ptr++;
        }
        if (*ptr == '\0') {
            break;
        }
        *ptr++ = '\0';
    }
}

const char kNotice[] = "/* This file is automatically generated. */\n";
